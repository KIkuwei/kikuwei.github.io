<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Wang congwei"><meta name="copyright" content="Wang congwei"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>vue | KIku</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.2.4/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/@unocss/runtime/mini.global.js"></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"kikuwei.github.io","root":"/","title":"松源晨雾的小站","version":"1.8.8","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]},"vendors":{"darken":"https://cdn.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="Vue3进阶：1.Vite + Vue3 composition API2.Vue3-element-admin  中后台的开发框架3.TypeScript + Vue34.Node爬虫5.Nuxt3  ssr渲染框架 Vue2  Vue3Vue2 (Options API) 开始在开发中小型项目的非常快，Vue2在开发中大型项目的时候缺陷比较大 (性能低、代码组织不好) ViteVite基于EC">
<meta property="og:type" content="article">
<meta property="og:title" content="vue">
<meta property="og:url" content="https://kikuwei.github.io/2021/05/01/vue/index.html">
<meta property="og:site_name" content="KIku">
<meta property="og:description" content="Vue3进阶：1.Vite + Vue3 composition API2.Vue3-element-admin  中后台的开发框架3.TypeScript + Vue34.Node爬虫5.Nuxt3  ssr渲染框架 Vue2  Vue3Vue2 (Options API) 开始在开发中小型项目的非常快，Vue2在开发中大型项目的时候缺陷比较大 (性能低、代码组织不好) ViteVite基于EC">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-01T05:12:49.000Z">
<meta property="article:modified_time" content="2022-02-17T11:19:36.260Z">
<meta property="article:author" content="Wang congwei">
<meta name="twitter:card" content="summary"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Wang congwei"><img width="96" loading="lazy" src="/images/1.jpg" alt="Wang congwei"></a><div class="site-author-name"><a href="/about/">Wang congwei</a></div><span class="site-name">KIku</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">0</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vite"><span class="toc-number">1.</span> <span class="toc-text">Vite</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vite%E5%85%B7%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">Vite具有以下特点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vite%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">Vite优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vite-build"><span class="toc-number">1.3.</span> <span class="toc-text">Vite build</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vite%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">Vite的配置文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Composition-API-%E7%BB%84%E5%90%88API"><span class="toc-number">2.</span> <span class="toc-text">Composition API (组合API)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setup%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">setup函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ref%E5%92%8Creactive"><span class="toc-number">4.</span> <span class="toc-text">Ref和reactive</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#toRefs%E5%92%8CtoRef"><span class="toc-number">5.</span> <span class="toc-text">toRefs和toRef</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">计算属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Watch"><span class="toc-number">7.</span> <span class="toc-text">Watch</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://KIkuwei.github.io/2021/05/01/vue/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Wang congwei"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="KIku"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">vue</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-05-01 13:12:49" itemprop="dateCreated datePublished" datetime="2021-05-01T13:12:49+08:00">2021-05-01</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2022-02-17 19:19:36" itemprop="dateModified" datetime="2022-02-17T19:19:36+08:00">2022-02-17</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><p>Vue3进阶：<br>1.Vite + Vue3 composition API<br>2.Vue3-element-admin  中后台的开发框架<br>3.TypeScript + Vue3<br>4.Node爬虫<br>5.Nuxt3  ssr渲染框架</p>
<p>Vue2  Vue3<br>Vue2 (Options API) 开始在开发中小型项目的非常快，Vue2在开发中大型项目的时候缺陷比较大 (性能低、代码组织不好)</p>
<h1 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h1><p>Vite基于ECMAScript标准原生模块系统(ES Modules)实现。<br>Vite 要求项目完全由 ES Module 模块组成，Vite可以使用@rollup&#x2F;plugin-commonjs插件将common.js 模块转换成 ES Modules</p>
<h2 id="Vite具有以下特点："><a href="#Vite具有以下特点：" class="headerlink" title="Vite具有以下特点："></a>Vite具有以下特点：</h2><p>快速的冷启动<br>即时热模块更新（HMR，Hot Module Replacement）<br>真正按需编译<br>Vite为 Vue 提供第一优先级支持 【Vue 3 单文件组件支持：@vitejs&#x2F;plugin-vue】 【Vue 2 支持：underfin&#x2F;vite-plugin-vue2】<br>开箱即用，避免各种Loader和Plugin的配置</p>
<h2 id="Vite优化"><a href="#Vite优化" class="headerlink" title="Vite优化"></a>Vite优化</h2><p>这就是 Vite 执行的所谓的“依赖预构建”。这个过程有两个目的:<br>1.处理CommonJS 和 UMD 模块的 兼容性<br>2.性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</p>
<h2 id="Vite-build"><a href="#Vite-build" class="headerlink" title="Vite build"></a>Vite build</h2><p>Vite在build的时候使用的构建工具是rollup，会把所有的资源进行打包，得到一个dist目录。<br>但是在dev的时候，对于js ts文件的处理用的是esbuild，不会一次性打包，而是访问什么资源，动态去编译资源(即时编译)</p>
<h2 id="Vite的配置文件"><a href="#Vite的配置文件" class="headerlink" title="Vite的配置文件"></a>Vite的配置文件</h2><p>配置文件名字必须叫：vite.config.js</p>
<p>import { defineConfig } from “vite”;<br>import path from “path”;<br>import vue from “@vitejs&#x2F;plugin-vue”;</p>
<p>&#x2F;&#x2F; <a target="_blank" rel="noopener" href="https://vitejs.dev/config/">https://vitejs.dev/config/</a><br>export default defineConfig({<br>  &#x2F;&#x2F;配置vue3插件<br>  plugins: [vue()],<br>  &#x2F;&#x2F;取别名<br>  resolve: {<br>    alias: {<br>      &#x2F;&#x2F;路径别名<br>      “@”: path.resolve(__dirname, “.&#x2F;src”),<br>    },<br>  },<br>  &#x2F;&#x2F;类似于webpack的devServer  (调试服务器)<br>  server: {<br>    host: “localhost”,<br>    port: 3000,<br>    open: true,<br>    strictPort: false,<br>    https: false,</p>
<p>    &#x2F;&#x2F; 代理<br>    &#x2F;&#x2F; proxy: {<br>    &#x2F;&#x2F;   ‘&#x2F;admin’: {<br>    &#x2F;&#x2F;     target: ‘<a target="_blank" rel="noopener" href="http://api.vite-admin.com&/#39;">http://api.vite-admin.com&#39;</a>,<br>    &#x2F;&#x2F;     changeOrigin: true,<br>    &#x2F;&#x2F;     rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^/admin&#x2F;, ‘’)<br>    &#x2F;&#x2F;   },<br>    &#x2F;&#x2F; }<br>  },<br>});</p>
<h1 id="Composition-API-组合API"><a href="#Composition-API-组合API" class="headerlink" title="Composition API (组合API)"></a>Composition API (组合API)</h1><p>React 类组件     — Vue  options API<br>React 函数组件   — Vue  composition API</p>
<p>Vue3中虽然使用了composition API，但是内部仍然会创建组件对象 </p>
<h1 id="setup函数"><a href="#setup函数" class="headerlink" title="setup函数"></a>setup函数</h1><p>  &#x2F;&#x2F;setup()就是composition API组件的入口，就相当于Options API的beforeCreate created，在beforeCreate之后 created之前执行<br>  setup() {<br>    const message &#x3D; “hello”<br>    let age &#x3D; ref(18);</p>
<p>    &#x2F;&#x2F;setup()函数是在组件创建之前执行的，所以在setup()函数中无法通过this来获取组件对象<br>    console.log(this, “xxxxxxxxxxxxxxxxxxx”)</p>
<p>    &#x2F;&#x2F;声明一个函数<br>    const doAdd &#x3D; () &#x3D;&gt; {<br>      age.value +&#x3D; 1;<br>    }</p>
<p>    &#x2F;&#x2F;在setup中有需要暴露给页面的数据，一定要return给页面<br>    &#x2F;&#x2F;可以返回一个对象，这个对象的属性被合并到渲染上下文，并可以在模板中直接使用<br>    return { message, age, doAdd, doAdd2 }</p>
<p>    &#x2F;&#x2F;我们也可以在setup函数返回一个通过h函数渲染后的虚拟dom<br>    &#x2F;&#x2F; return () &#x3D;&gt; h(‘div’, { style: { color: “red” } }, [“xx”, “99”])<br>  }</p>
<h1 id="Ref和reactive"><a href="#Ref和reactive" class="headerlink" title="Ref和reactive"></a>Ref和reactive</h1><p>  &#x2F;&#x2F;ref响应式数据的问题：<br>    &#x2F;&#x2F;1. 默认情况下直接声明的变量是非响应式 (数据变了，页面不会变，因为内部没有数据劫持)<br>    &#x2F;&#x2F;2. 为了让数据能够成为响应式的数据，我们可以引入ref来实现这个功能。ref可以将一个变量包装为响应式的变量<br>    &#x2F;&#x2F;3. 当通过ref将变量包装为响应式变量之后，内部就会有数据劫持的功能(对于基本数据类型会使用set和get做数据劫持，对于引用类型会用Proxy来做数据劫持)。真正的数据是方法ref.value里面的<br>    &#x2F;&#x2F;4. 在修改ref变量的时候，js代码中需要使用ref.value&#x3D;xx来修改，页面中就可以直接使用ref变量来修改<br>    &#x2F;&#x2F;5. ref的使用场景：将一个变量包装为响应式变量<br>    &#x2F;&#x2F;6. 把数据包装为响应的数据可以用ref的方式，也可以用reactive方式，优先使用ref方式<br>    const message &#x3D; ref(“hello”)<br>    const a &#x3D; 18;<br>    const age &#x3D; ref(a);<br>    console.log(age) &#x2F;&#x2F;Refimpl类型对象<br>    const arr &#x3D; ref([‘a’, ‘b’])<br>    console.log(arr) &#x2F;&#x2F; Proxy对象</p>
<p>    &#x2F;&#x2F;reactive响应式的数据的问题：<br>    &#x2F;&#x2F;1.reactive可以将一组数据包装为响应的数据 （只能包装对象）<br>    &#x2F;&#x2F;2.reactive是将数据包装为代理对象，然后通过代理来做数据劫持的<br>    &#x2F;&#x2F;3.reactive将数据包装为响应式数据之后，不要再用解构赋值了，因为这会让数据失去响应能力，对应的我们可以使用toRefs<br>    const o &#x3D; {<br>      name: “张三”,<br>      gender: “男”<br>    }<br>    const obj &#x3D; reactive(o)</p>
<h1 id="toRefs和toRef"><a href="#toRefs和toRef" class="headerlink" title="toRefs和toRef"></a>toRefs和toRef</h1><p>&#x2F;&#x2F;toRefs解构reactive数据，并且保持数据的响应式<br>    &#x2F;&#x2F;toRefs解构出来的数据类型是RefImpl类型(引用类型：引用reactive数据) — 浅拷贝<br>    const { name, gender } &#x3D; toRefs(obj);<br>    const { message } &#x3D; toRefs(obj2);<br>    console.log(message, “xxxxxxxxxxxxx”)</p>
<p>    &#x2F;&#x2F;toRef解构reactive数据中的一个数据(手动指定解构谁)<br>    const age &#x3D; toRef(obj, “age”);</p>
<p>    &#x2F;&#x2F;isRef()判断某个变量是否是Ref类型的变量<br>    console.log(isRef(age), “0000”)</p>
<p>    const modify &#x3D; () &#x3D;&gt; {<br>      &#x2F;&#x2F;下面两种方式修改数据都可以保持数据的响应式<br>      obj.name &#x3D; “李四”<br>      gender.value &#x3D; “女”<br>      age.value &#x3D; “666”<br>    }</p>
<p>  &#x2F;*<br>    总结：<br>    1. ref ： 经过ref包装之后的数据是一个全新的对象，该对象和原来的数据就没有关系了，相当于深拷贝(ref数据修改之后 原数据不变 页面会刷新)。该结论针对基本数据类型有效。<br>    2. reactive ： 经过reactive包装之后的数据是一个代理对象，是通过代理对象来修改目标对象（reactive数据该了 原数据也会修改 页面会刷新）<br>    3. toRefs :  用于解构reactive、普通数据的，解构之后会得到RefImpl类型的对象，相当于浅拷贝（解构出的RefImpl数据修改之后 reactive&#x2F;普通数据也会修改 页面不会不刷新取决于原数据是否是响应式 ）<br>    4. toRef :  用于解构reactive、普通数据的，解构之后会得到RefImpl类型的对象，相当于浅拷贝（解构出的RefImpl数据修改之后 reactive&#x2F;普通数据也会修改 页面不会不刷新取决于原数据是否是响应式 ）<br>    *&#x2F;</p>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>const count &#x3D; ref(10)<br>    &#x2F;&#x2F;计算属性：如果只入参一个get函数，此时计算属性是只读的，不可以修改<br>    const powCount &#x3D; computed(() &#x3D;&gt; Math.pow(count.value, 2))<br>    &#x2F;&#x2F; wrong<br>    &#x2F;&#x2F;powCount.value++</p>
<p>    &#x2F;&#x2F;计算属性可以入参一个对象，对象里面包含set和get函数<br>    &#x2F;&#x2F;其中在使用计算属性的时候，会默认执行get函数；在给计算属性赋值的时候，会默认执行get函数<br>    const doubleCount &#x3D; computed({<br>      set(value) {<br>        count.value &#x3D; value;<br>      },<br>      get() {<br>        return count.value * 2<br>      }<br>    })<br>    doubleCount.value &#x3D; 100;</p>
<h1 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h1><p>&#x2F;&#x2F;watch()可以入参三个参数<br>    &#x2F;&#x2F;1.想要侦听的响应式引用或getter函数<br>    &#x2F;&#x2F;2.监听数据的回调函数，该回调的参数有两个，前一个是newValue，后一个是oldValue<br>    &#x2F;&#x2F;3.监听的配置参数 是一个对象，如{ immediate: true }，这样可以让初次挂在时执行watch的回调</p>
<p>    &#x2F;&#x2F;监听state变化 : 入参函数<br>    watch(() &#x3D;&gt; state.count, (count, prevCount) &#x3D;&gt; {<br>      console.log(count, prevCount)<br>    }, { immediate: true })</p>
<p>    &#x2F;&#x2F;深度监听<br>    watch(() &#x3D;&gt; state, (state, prevState) &#x3D;&gt; {<br>      console.log(state, prevState)<br>    },<br>      { deep: true })</p>
<p>    &#x2F;&#x2F;完全深度监听<br>    watch(() &#x3D;&gt; _.cloneDeep(state), (state, prevState) &#x3D;&gt; {<br>      console.log(state, prevState, “xxx”)<br>    },<br>      { deep: true })</p>
<p>    &#x2F;&#x2F;监听ref数据 : 直接入参ref对象<br>    watch(title, (title, prevTitle) &#x3D;&gt; {<br>      console.log(title, prevTitle)<br>    })</p>
<p>    &#x2F;&#x2F;监听一组数据<br>    watch([title, () &#x3D;&gt; state.count], ([title, count], [prevTitle, prevCount]) &#x3D;&gt; {<br>      console.log(title, count, prevTitle, prevCount)<br>    })</p>
</div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="Donate" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Wang congwei</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://kikuwei.github.io/2021/05/01/vue/" title="vue">https://kikuwei.github.io/2021/05/01/vue/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/02/17/es6/" rel="next" title="es6"><span class="post-nav-text">es6</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Wang congwei</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.0.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.8.8</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>